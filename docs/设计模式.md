`设计模式 Java`
[原文地址](https://www.bookstack.cn/books/design-pattern-java)

# 一、入门

## 1.1. 概述

### 1.1.1 招式 VS 内功(一)
> "内功"大增，再结合日益纯熟的"招式"

招式：Java、C#、C ++、IDEA、JSP、MySQL等
内功：数据结构、算法、设计模式、重构、软件工程

`设计模式起源`
模式起源于建筑领域
大量调查研究和资料手机，发现人们对舒适住宅和城市环境存在一些共同`认同规律`
把这些`认同规律`归纳为253个模式，从前提条件、目标问题、解决方案三个方面进行描述，给出用户需求到建筑环境结构设计直至经典实例的过程模型

`模式是在特定环境下人们解决某类重复问题的一套成功或者有效的解决方案`

GoF 归纳发表了23种在软件开发中使用频率较高的设计模式，用于统一沟通面向对象方法在分析、设计和实现间的鸿沟

软件模式基础结构：问题描述、前提条件、解法和效果

### 1.1.2 招式 VS 内功(二)
> 通过一些成熟的设计方案来指导新项目的开发和设计，便于开发出具有更好的灵活性和可扩展性的软件系统
> 一般定义：设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性

根据用途，设计模式可分为创建型、结构型、行为型三种
* 创建型（5种）：用于描述如何创建对象
* 结构型（7种）：用于描述如何实现类或对象的组合
* 行为型（11种）：用于描述类或对象怎样交互以及怎样分配职责

`常用设计模式一览表-学习难度-使用频率`

![design-pattern-java](https://cdn.jsdelivr.net/gh/wudg/picgo@master/images/design-pattern-java.png)

### 1.1.3 招式 VS 内功(三)

`用途`
1. 实现可维护性复用的设计方案
2. 提供一套通用的设计词汇和形式，方便开发人员之间的沟通，减少结构成本，因为设计模式是跨语言、跨平台、跨应用、跨国界的
3. 兼顾系统可重用性和可扩展性，更好地重用已有的设计方案、功能模块，避免重复造轮子。
4. 便于他人理解你的设计思路和实现方案

`重点`
1. 能掌握，关键在于多思考、多实践
2. 了解每一种设计模式的意图，指定使用这个设计模式的使用场景以及使用该模式的优势
3. 在实际开发种灵活运用
4. 不可滥用，每个模式都有自己的适用场景，不能为了使用模式而使用模式
5. 不管这个设计模式难度以及使用频率如何，都应好好学学，每一个模式都是一种计策，为解决某一类问题二诞生
6. 实际开发中设计模式信手拈来


## 1.2 面向对象设计原则
> 在支持可维护性的同时，提高系统可复用性是一个至关重要的问题
> 面向对象设计原则为支持可维护性可复用性而诞生


![7种面向对象设计原则](https://cdn.jsdelivr.net/gh/wudg/picgo@master/images/origin-object-7-principle.png)

### 1.2.1 面向对象设计原则-单一职责原则
> 一个类只负责一个功能领域种的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因
> 一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小

`实例：`
需求：CRM系统中客户信息图形统计模块设计方案

初始设计方案结构图：

![单一职责-Source](https://cdn.jsdelivr.net/gh/wudg/picgo@master/images/principal-single-responsibilities-source.jpg)

`描述：`
1. getConnection()  用于连接数据库
2. findCustomers() 用于查询所有客户信息
3. createChart()和displayChart() 分别用于创建和显示图表

`重构`
使用单一职责原则对其进行重构

![单一职责-Target](https://cdn.jsdelivr.net/gh/wudg/picgo@master/images/principal-single-responsibilities-target.jpg)

`描述：`
1. DBUtil：负责连接数据库，其中包含获取数据连接的方法
2. CustomerDAO：负责操作数据库中customer表，其中可以包含CURD方法
3. CustomerDataChart：负责图表的创建和显示


### 1.2.2 面向对象设计原则-开闭原则
> 最重要。
> 一个软件实体应当对扩展开放，对修改关闭。即软件实体尽量在不修改原有的代码情况下进行扩展
> 软件实体：一个软件模块、一个由多个类组成的局部结构或者要给独立的类

任何软件的需求都会随着时间的推移而发生变化。当系统需要面对新的需求时，我们一共尽量保证系统的设计框架是稳定的。
使得系统在拥有适应性和灵活性的同时具备良好的稳定性和延续性

`抽象化是开闭原则的关键`

`实例`
需求：CRM系统需要可以显示各种类型的图表，如饼状图和柱状图等，为了支持多种图表显示方式，原始设计方案如图

![开闭原则-原始](https://cdn.jsdelivr.net/gh/wudg/picgo@master/images/principal-open-close-source.jpg)

ChartDisplay 类中的display() 方法代码片段如下：
```java
......  
if (type.equals("pie")) {  
    PieChart chart = new PieChart();  
    chart.display();  
}  
else if (type.equals("bar")) {  
    BarChart chart = new BarChart();  
    chart.display();  
}  
......
```

`描述`

在该代码中，如果需要增加一个新的图表类，如折线图LineChart，则需要修改ChartDisplay类中的display() 方法的源代码，增加新的判断逻辑，违背了开闭原则

`重构`

现对该系统进行重构，可以通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码

具体做法如下：
1. 增加要给抽象图表类 AbstractChart，作为各种具体图表类的基类
2. ChartDisplay类针对抽象图表类进行编程，由客户端决定具体使用哪种图表

![开闭原则-重构](https://cdn.jsdelivr.net/gh/wudg/picgo@master/images/principal-single-responsibilities-target.jpg)

`描述`
1. 引入抽象图表类AbstractChart，ChartDisplay针对抽象图表类进行编程，并通过setChart()方法由客户端来设置具体图表对象
2. 如果需要增加一种新的图表，如折线图LineChart，则只需将LineChart继承AbstractChart即可



### 1.2.3 面向对象设计原则-里氏替换原则
> 所有引用基类（父类）的地方必须能透明使用其子类的对象

在软件中将基类对象替换成它的子类对象，程序将不产生任何错误和异常，反之则不行

如父类 BaseClass，子类 SubClass
任意一个方法，如果可以接受一个 BaseClass类型的对象的话，那么这个方法一定能接受一个 SubClass 的对象

`注意事项`
1. 子类所有的方法必须在父类中声明
2. 尽量把父类设计为抽象类或者接口，让子类继承父类或者实现父接口，并在父类中声明方法。里氏替换原则是开闭原则的具体实现手段之一
3. Java中，在编译阶段，Java编译器会检查程序是否符合里氏替换原则


`实例`

需求：客户可以分为VIP客户和普通客户两类，系统需要提供一个发送Email功能，原始设计方案如下

![里氏替换-原始](https://cdn.jsdelivr.net/gh/wudg/picgo@master/images/lsp-principal-source.jpg)


`描述`

1. 无论是普通用户还是VIP用户，发送邮件的过程都是相同的，即send()方法中代码重复
2. 如果新增其他类型用户，扩展性差

`重构`

`描述`

1. 考虑增加一个抽象客户类 Customer
2. CommonCustomer和VIPCustomer 类作为抽象客户类的子类
3. 邮件发送类EmailSender 针对抽象客户类Customer编程，根据里氏替换原则，能够接受基类对象的方法必然能够接受子类对象

![里氏替换-重构](https://cdn.jsdelivr.net/gh/wudg/picgo@master/images/lsp-principal-target.jpg)

`注意`

里氏替换原则是实现开闭原则的重要方式之一。除了在传递参数使用基类对象时，在定义成员变量、定义局部变量、确定方法返回类型时都可以使用里氏替换原则

### 1.2.4 面向对象设计原则-依赖倒转原则
> 抽象不应该依赖于细节，细节应当依赖于抽象

依赖倒转原则要求我们在传递参数时或在关联关系中，尽量引用层次高的抽象类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，不要用具体的类来做这些事情。

实现依赖倒转原则时，需要针对抽象层编程，而将具体类的对象通过依赖注入的方式注入到其他对象中，依赖注入是指当要给对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。

常用的注入方式：构造注入、设值注入（Setter）和接口注入

`实例`

需求：在某CRm中，系统经常需要将存储在TXT或者Excel文件中的客户信息转存到数据库中，因此需要进行数据格式转换

原始设计方案结构图:

![依赖注入-原始](https://cdn.jsdelivr.net/gh/wudg/picgo@master/images/principal-di-source.jpg)

`存在问题：`
1. 每次转换数据时数据来源不一定相同，因此需要更换数据转换类，如有时候需要将TXTDataConvertor改为ExcelDataConvertor，此时需要修改CustomerDAO  源代码
2. 引入并使用新的数据转换类时也不得不改CustomerDAO源代码
3. 扩展性差，违背开闭原则


`重构`

`描述`
1. 引入抽象数据转换类DataConvertor，CustomerDAO针对抽象类DataConvertor编程
2. 将具体的转换类名存储在配置文件中，符合依赖倒转原则
3. 根据里氏替换原则，程序在运行时，具体数据转换类对象将替换DataConvertor类型的对象
4. 引入新的数据转换类时无需修改源代码，只需修改配置文件


![依赖注入-重构](https://cdn.jsdelivr.net/gh/wudg/picgo@master/images/principal-di-target.jpg)

`上述重构中，使用了开闭原则、里氏替换原则和依赖倒转原则，大多数情况下，这三个设计原则会同时出现，开闭原则时目标，里氏替换原则时基础，依赖倒转原则是手段，相辅相成，相互补充，目标一致`


### 1.2.5 面向对象设计原则-接口隔离原则
> 使用多个功能单一的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口
> 当一个接口太大时，需要将它分割成多个更小的接口，使得实现该接口的子类仅需知道与之相关的方法即可

`实例`

需求：某CRM系统的客户数据显示模块设计如图所示


![接口隔离-原始](https://cdn.jsdelivr.net/gh/wudg/picgo@master/images/isp-principal-source.jpg)

`描述`

1. dataRead()  用于从文件中读取数据
2. transformToXML() 用于将数据转换成 XMl 格式
3. createChart()/display() 用于创建图表和显示图表
4. createReport()/displayReport() 用于创建文字报表和显示文字报表

`存在问题：`
1. 接口庞大，不灵活。
2. 部分功能只需其中部分方法，但每次都需要实现该接口中所有的方法，代码冗余


`重构`

![接口隔离-重构](https://cdn.jsdelivr.net/gh/wudg/picgo@master/images/isp-principal-target.jpg)

`描述`

1. 使用接口隔离原则时，注意控制接口粒度，不能太大或者太小


### 1.2.6 面向对象设计原则-合成复用原则
> 尽量使用对象组合，和不是继承来达成复用的目的
> 在新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分
> 在面向对象设计中，通过组合/聚合或者通过继承来复用已有的设计和实现
> 组合/聚合使系统更加灵活，降低类之间耦合度，适当使用继承有助于对问题的理解，降低复杂度，而滥用继承则会更加系统构建和维护的难度以及系统的复杂度

`如何抉择组合/聚合和继承`

* Has-A：使用组合/聚合
* Is-A：使用继承

`实例`

描述：CRM系统设计初期，考虑客户数量不多，采用MySQL作为数据库，与数据库操作相关的类如 CustomerDAO 都需要连接数据库，而连接数据库的方法被封装在DBUtil中，由于需要重用DBUtil类的getConenction()方法，设计人员将CustomerDAO作为DBUtil的子类

![合成复用-原始](https://cdn.jsdelivr.net/gh/wudg/picgo@master/images/principal-carp-source.jpg)

`问题描述`
1. 随着客户数量增加，系统决定使用Oracle数据库，因此需要新增要给OracleDbUtil类来连接Oracle数据库
2. 由于初始设计方案中CustomerDAO和DBUtil之间是继承关系，因此更换数据库连接方式时需要修改CustomerDAO的源代码，使其继承OracleDBUtil类
3. 违背开闭原则

`重构`

`描述`
1. 根据合成复用原则，在实现复用时，少用继承，多用关联
2. CustomerDAO和DBUtil之间的关系由继承变为关联，采用依赖注入方式将DBUtil对象注入CustomerDAO中
3. 如果需要对DBUtil的功能进行扩展，可以通过其子类来实现，如MySQLDBUtil和OracleDBUtil类

![合成复用-重构](https://cdn.jsdelivr.net/gh/wudg/picgo@master/images/principal-carp-target.jpg)


### 1.2.7 面向对象设计原则-迪米特法则
> 又称最少知道原则。一个软件实体应当尽可能少地与其他实体发生相互作用
> 当一个模块发生修改时，会尽量少地影响其他模块，扩展相对容易，且降低系统耦合度，使类之间保持松散的耦合关系


迪米特法则：不要和"陌生人"说话，只与"朋友"通信

`朋友`

1. 当前对象本身（this）
2. 以参数形式传入当前对象方法中的对象
3. 当前对象的成员对象（如果成员对象是一个集合，则集合中的元素也是）
4. 当前对象所创建的对象

`实例`

需求：某CRM系统包含很多业务操作窗口，这些窗口中，某些界面控件间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应。如当一个按钮被点击时，对应的列表框、组合框、文本框、文本标签等都将发生改变

`描述`
1. 界面控件之间交互关系复杂
2. 在该窗口中增加新的界面控件时需要修改与其交互的其他控件的源代码，系统扩展性差，也不便于增删控件

![迪米特法则-原始](https://cdn.jsdelivr.net/gh/wudg/picgo@master/images/principal-lkp-source.jpg)


`重构`

`描述`
1. 引入一个专门用于控制界面控件交互的中间类(Mediator) 来降低界面控件之间的耦合度
2. 引入中间类后界面控件之间不再发生直接引用，而是先将请求转发给中间类，在有中间类完成对其他控件的调用
3. 当需要增加或者删除控件时，只需修改中间类即可

![迪米特法则-重构](https://cdn.jsdelivr.net/gh/wudg/picgo@master/images/principal-lkp-target.jpg)


